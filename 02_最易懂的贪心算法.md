## 2.1 算法解释
(参考 《数据结构与算法分析 C++描述》 #10.1 贪心算法)

贪心算法分阶段工作，在每一个阶段，选择**局部最优解**。当算法终止时，希望局部最优就是全局最优。**如果真是这样的话，那么算法就是正确的；否则就会得到一个次最优解**。

## 2.2 分配问题
### 455 Assign Cookies
```cpp
//对vector进行排序
//对于多维vector对首元素排序
//Defined in header <algorithm>
sort(vec.begin(), vec.end());
```
### 135 Candy
```cpp
//对vector进行求和, 第三个参数表示和的初值
accumulate(vec.begin(), vec.end(), 0);
```

## 2.3 区间问题
### 435 Non-overlapping Intervals
```cpp
//对vector<vector<int>>按照第二坐标排序时
sort(vec.begin(), vec.end(), [](vector<int> a, vector<int> b) {
        return a[1] < b[1];
    });
```
Trick: 用vector<pair<int, int>>来代替vector<vector<int>>会更快，如下：
```cpp
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    int n = intervals.size();
    if (!n)
        return 0;
    //保留结尾小且不与之前相重叠的
    vector<pair<int, int>> v;
    for(int i = 0; i < n; ++i){
        v.push_back({intervals[i][0], intervals[i][1]});
    }
    sort(v.begin(), v.end(), [](pair<int, int> a, pair<int, int> b) {
        return (a.second < b.second);
    });
    int num = 0, right = v[0].second;
    for(int i = 1; i < n; ++i){
        if (v[i].first < right){
            ++num;
        } else {
            right = v[i].second;
        }
    }
    return num;
}
```

## 2.4 练习
### 605 Can Place Flowers
Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed **without violating the no-adjacent-flowers rule**.

思路： 找到满足的条件的第一个种花位置，种上花，再寻找下一个位置。

```cpp
bool canPlaceFlowers(vector<int>& flowerbed, int n) {
    if (n == 0)
        return true;
    int s = flowerbed.size();
    int num = 0;
    for (int i = 0; i < s; ++i){
        if (flowerbed[i] == 0){
            if (i == 0 || flowerbed[i-1] == 0){
                if (i == s - 1 || flowerbed[i+1] == 0){
                    flowerbed[i] = 1;
                    ++num;
                }
                //不用等到最终求出最大能种花数
                if (num >= n)
                    return true;
            }
        }
    }
    return false;
}
```

### 452 Minimum Number of Arrows to Burst Ballons
An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. Given an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons.

思路：

错误思路1：优先删除有公共交集的数量最多的点集，再进行递归

    反例： [ [3, 4] [4, 8] [4, 8] [4, 12] [7, 12] [7, 13] [9, 15] [9, 17] ]

错误思路2：优先删除最靠前的有公共交集的点集，再进行递归

    反例： 输入size过大时会造成Time Limit Exceeded(因为递归每次加1，次数过多)

正确思路1：优先删除最靠前的有公共交集的点集，并继续循环。

Trick: 用vector<pair<int, int>>来代替vector<vector<int>>会更快

```cpp
int findMinArrowShots(vector<vector<int>>& points) {
    int s = points.size();
    if (s < 2)
        return s;
    vector<pair<int, int>> v;
    for(int m = 0; m < s; ++m){
        v.push_back({points[m][0], points[m][1]});
    }
    sort(v.begin(), v.end());
    int i = 0, j, left = 0, right = 0, num = 0;
    while (i < s){
        ++num;
        left = v[i].first;
        right = v[i].second;
        while (left <= right){
            if (j == s - 1){
                ++j;
                break;
            }
            left = max(left, v[j+1].first);
            right = min(right, v[j+1].second);
            ++j;
        }
        i = j;
    }
    return num;
}
```

正确思路2： 按Xend排序，并以最前面的Xend作为射箭点，什么时候左端比该射箭点大时，就需要射下一只箭
```cpp
int findMinArrowShots(vector<vector<int>>& points) {
    int s = points.size();
    if (s < 2)
        return s;
    vector<pair<int, int>> v;
    for(int i = 0; i < s; ++i){
        v.push_back({points[i][0], points[i][1]});
    }
    sort(v.begin(), v.end(), [](pair<int, int> a, pair<int, int> b) {
        return (a.second < b.second);
    });
    int pos = v[0].second;
    int ans = 1;
    for (int i = 0; i < s; ++i) {
        if (v[i].first > pos){
            ++ans;
            pos = v[i].second;
        }      
    }
    return ans;
}
```
### 763 Partition Labels
A string S of lowercase English letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.

思路：找出所有字母最后出现的索引，遍历整个字符串，如果当前为之前所有字母最后一次出现的位置及之后，截断

```cpp
vector<int> partitionLabels(string S) {
    int n = S.size();
    if (n < 2)
        return vector<int>{n};
    int last[26];
    for (int i = 0; i < n; ++i){
        last[S[i] - 'a'] = i;
    }
    vector<int> ret;
    int start = 0, end = 0;
    for (int i = 0; i < n; ++i) {
        end = max(end, last[S[i]-'a']);
        if (i == end) {
            ret.push_back(end - start + 1);
            start = end + 1;
            //下句可省略
            //end = start;
        }
    }
    return ret;
}
```
### 122 Best Time to Buy and Sell Stock II
Say you have an array prices for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

思路：对能赚的每一天的利润加起来
```cpp
int maxProfit(vector<int>& prices) {
    int n = prices.size();
    if (n < 2)
        return 0;
    int ret = 0;
    for (int i = 1; i < n; ++i){
        ret += max(0, prices[i] - prices[i-1]);
    }
    return ret;
}
```